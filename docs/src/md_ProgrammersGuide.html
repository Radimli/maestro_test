<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Maestro Audio Framework: Maestro Audio Framework Programmer&#39;s Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="new_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Maestro Audio Framework<span id="projectnumber">&#160;v 2.0.0</span>
   </div>
   <div id="projectbrief">NXP Semiconductors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_ProgrammersGuide.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Maestro Audio Framework Programmer's Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md7"></a> </p>
<h1><a class="anchor" id="autotoc_md8"></a>
Introduction</h1>
<p>Maestro audio framework provides instruments for playback and capture of different audio streams. In order to do that the framework uses API for creating various audio and voice pipelines with the support of media and track information. This document describes the framework in its detail, and the usage of API for pipeline creation using different elements. The framework needs an operating system in order to create different tasks for audio processing and communication with the application.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Architecture overview</h1>
<p>A high-level block diagram of the streamer used in Maestro is shown below. An element is the most important class of objects in the streamer (see <code>streamer_element.c</code>). A chain of elements will be created and linked together when a <a href="pipeline_8c.html">pipeline</a> is created. Data flows through this chain of elements in form of data buffers. An element has one specific function, which can be the reading of data from a file, decoding of this data, or outputting this data to a sink device. By chaining together several such elements, a pipeline is created that can do a specific task, for example, the playback.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Pipeline</h1>
<div class="image">
<object type="image/svg+xml" data="maestro.svg" style="pointer-events: none;"></object>
<div class="caption">
maestro overview</div></div>
    <p>The pipeline is created within the <code>streamer_create</code> API using the <code>streamer_create_pipeline</code> call. In the example applications provided in the MCUXpresso SDK the pipeline is created in the <code>app_streamer.c</code> file. In order to create a pipeline user needs to provide a <code>PipelineElements</code> structure consisting of array of element indexes <code>ElementIndex</code> and the number of elements in the pipeline. Then the pipeline is built automatically and user can specify the properties of the elements using the <code>streamer_set_property</code> API. All the element properties can be found in the <code>streamer_element_properties.h</code> file.</p>
<p>The streamer can handle up to two pipelines within a single task. The first pipeline with index 0 can be created using the <code>streamer_create</code> function as described above. Then the <code>streamer_create_pipeline</code> function should be used to create the second pipeline (pipeline with index 1). An example creation can be found in the <code>app_streamer.c</code> file in the <a class="el" href="md_maestro__sync.html">maestro_sync_example</a>. Both pipelines are processed sequentially, so after the first pipeline is processed, the second pipeline is processed.</p>
<p>After the pipeline is sucessfully created, all elements and entire pipeline are in <code>STATE_NULL</code> state. A user can start the streamer by setting the pipeline state to <code>STATE_PLAYING</code> using the <code>streamer_set_state</code> function. The pipeline can also be paused or stopped using the same function. Use the <code>STATE_PAUSED</code> to pause and use <code>STATE_NULL</code> to stop. The function changes the state of each element that is in the pipeline in turn, and after all the elements have obtained the desired state, the state of entire pipeline is changed.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Elements</h1>
<p>The current version of the Maestro framework supports several types of elements (<code>StreamElementType</code>). In each pipeline should be used one source element (elements with the <code>_SRC</code> suffix) and one sink element (elements with the <code>_SINK</code> suffix). A <code>decoder</code>, <code>encoder</code> or <code>audio_proc</code> element can be connected between these two elements. The <code>audio_proc</code> element can be used more than once within the same pipeline.</p>
<p>Each element type (<code>StreamElementType</code>) has several functions that are determined by a unique element index (<code>ElementIndex</code>). These indexes are used to create a pipeline, and each element index can only be used once in the same pipeline. The <code>type_lookup_table</code> shows which <code>StreamElementType</code> supports which <code>ElementIndex</code>.</p>
<p>Each element index (<code>ElementIndex</code>) has its own properties and a list of these properties can be found in the <code>streamer_element_properties.h</code> file. These properties are divided into groups and each group is identified by a property mask (e.g. for speaker it is <code>PROP_SPEAKER_MASK</code>). Then the <code>property_lookup_table</code> in the <code>streamer_msg.c</code> file determines which property group relates to which element index (<code>ElementIndex</code>). When an element is created and added to the pipeline, its properties are set to their defalut values. Default values can be seen in the initialization function of a particular element. The initialization functions are specified in the <code>element_list</code> array in the <code>streamer_element.c</code> file (e.g. for the <code>audio_proc</code> element it is the <code>audio_proc_init_element</code> function). The user can get the value of the property using the <code>streamer_get_property</code> function or change its value using the <code>streamer_set_property</code> function.</p>
<p>The source code of the elements can be found in the <code>middleware\audio_voice\maestro\src\elements\</code> folder.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Add a new element type</h2>
<p>The user can add a new element type (<code>StreamElementType</code>) to the Maestro audio framework. For this, the following steps need to be done.</p>
<ul>
<li>Add a new element type to the <code>StreamElementType</code> enum type in the <code>streamer_api.h</code>.</li>
<li>Create a new *.c and *.h files for the new element type in the <code>middleware\audio_voice\maestro\src\elements\</code> folder. All necessary structures and functions (functions for src pads, sink pads and element itself) needs to be defined in these files. Inspiration can be found in other elements.</li>
<li>Link the initialization function to the element type in the <code>element_list</code> array in the <code>streamer_element.c</code> file. To do this, a new definition that enables the element needs to be created (e.g. there is a <code>STREAMER_ENABLE_AUDIO_PROC</code> definition for the <code>audio_proc</code> element).</li>
<li>Associate the newly created element type with an element index (<code>ElementIndex</code>) by adding a new pair to the <code>type_lookup_table</code> in the <code>streamer.c</code> file.</li>
<li>If the user wants to use the newly created element in an application, the definiton that enables the element must be defined at the project level.</li>
</ul>
<p>Mostly the user doesn't need to create a new element type, but just create an element index.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Add a new element index</h2>
<p>To create a new element index in the Maestro audio framework, follow these steps:</p>
<ul>
<li>Add a new element index to the <code>ElementIndex</code> enum type in the <code>streamer_api.h</code>.</li>
<li>Create the required properties for the newly created element index in the <code>streamer_element_properties.h</code> file.</li>
<li>Associate the newly created property group with newly created element index by adding a new pair to the <code>property_lookup_table</code> in the <code>streamer_msg.c</code> file.</li>
<li>Associate the newly created element index with an element type (<code>StreamElementType</code>) by adding a new pair to the <code>type_lookup_table</code> in the <code>streamer.c</code> file.</li>
<li>Add support for the created properties to functions of the associated element type. These functions are defined in files that correspond to a particular element type. The files are located in the <code>middleware\audio_voice\maestro\src\elements\</code> folder.</li>
</ul>
<p>**It is important to know that each element type (<code>StreamElementType</code>) can be associated with more than one element index (<code>ElementIndex</code>), but each element index (<code>ElementIndex</code>) can be associated with only one element type (<code>StreamElementType</code>).**</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Pads</h1>
<p>Pads are elements' inputs and outputs. A pad can be viewed as a "plug" or "port" on an element where links may be made with other elements, and through which data can flow to or from those elements. Data flows out of an element through a source pad, and elements accept incoming data through a sink pad. Source and sink elements have only source and sink pads, respectively. For detailed information about pads, please see the API reference from <code>pad.c</code>.</p>
<div class="image">
<object type="image/svg+xml" data="elements.svg" style="pointer-events: none;"></object>
<div class="caption">
data flow</div></div>
    <h1><a class="anchor" id="autotoc_md15"></a>
Internal communication</h1>
<p>The streamer (the core of the framework) provides several mechanisms for communication and data exchange between the application, a pipeline, and pipeline elements:</p><ul>
<li><b style="color:red">Buffers</b> are objects for passing streaming data between elements in the pipeline. Buffers always travel from sources to sinks (downstream).</li>
<li><b style="color:green">Messages</b> are objects sent from the application to the streamer task to construct, configure, and control a streamer pipeline.</li>
<li><b style="color:blue">Callbacks</b> are used to transmit information such as errors, tags, state changes, etc. from the pipeline and elements to the application.</li>
<li><b style="color:purple">Events</b> are objects sent between elements. Events can travel upstream and downstream. Events may also be sent to the application</li>
<li><b style="color:gray">Queries</b> allow applications to request information such as duration or current playback position from the pipeline. Elements can also use queries to request information from their peer elements (such as the file size or duration). They can be used both ways within a pipeline, but upstream queries are more common</li>
</ul>
<div class="image">
<object type="image/svg+xml" data="communication.svg" style="pointer-events: none;"></object>
<div class="caption">
communication</div></div>
    <h1><a class="anchor" id="autotoc_md16"></a>
Decoders and encoders</h1>
<p>Maestro framework uses a common codec interface for decoding purposes and a common encoder interface for encoding. Those interfaces encapsulate the usage of specific codecs. Reference codecs are available in audio-voice-components repository which should be in <code>\middleware\audio_voice\components\</code> folder.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Common codec interface</h2>
<p>The Common Codec Interface is the intended interface for all used <b>decoders</b>. The framework will integrate a CCI decoder element into the streamer to interface with all decoders.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Using the CCI to interface with Metadata</h2>
<ul>
<li><code>cci_extract_meta_data</code> must be called before any other Codec Interface APIs. This API extracts the metadata information of the codec and fills this information in the file_meta_data_t structure. The file_meta_data_t structure must be allocated by the application.</li>
<li>This function first extracts the input file extension and based on that it calls the specific codec’s metadata extraction function. If it finds an invalid extension or unsupported extension then it returns with META_DATA_FILE_NOT_SUPPORTED code for any unsupported file format.</li>
<li>If this API finds the valid metadata then it returns with META_DATA_FOUND code. If this API does not find any metadata information then it returns with META_DATA_NOT_FOUND code. It also returns with META_DATA_FILE_NOT_SUPPORTED code for any unsupported file format.</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
Using the CCI to interface with Decoders</h2>
<ul>
<li><code>codec_get_mem_info</code> gets the memory requirement based on the specific decoder stream type. It returns the size in bytes of the specific codec. The user of the decoders must allocate memory of this size and this memory is used by the initialization API. The user or application must pass this allocated memory pointer to the init API.</li>
<li><code>codec_init</code> must be called before the codec’s decode API. This API calls the codec-specific initialization function based on the codec stream type. This API allocates the memory to the codec main structure and also initializes the codec main structure parameters. It also registers the call back functions to the codec which will be used by the codec to read or seek the input stream.</li>
<li><code>codec_decode</code> is the main decoding API of the codec. This API calls the codec-specific decoding function based on the codec stream type. This API decodes the input raw stream and fills the PCM output samples into codec output PCM buffer. This API gives the information about the number of samples produced by the codec and also gives the pointer of the codec output PCM samples buffer.</li>
<li><code>codec_get_pcm_samples</code> must be called after the codec’s decode API. This API calls the codec specific Get PCM Sample API based on the codec stream type. This API gets the PCM samples from the codec in constant block size and fills them into the output PCM buffer. It returns the number of samples get from the codec and also gives the pointer of the output PCM buffer.</li>
<li><code>codec_reset</code> calls the codec specific reset API base on stream type and resets the codec.</li>
<li><code>codec_seek</code> accepts the seek bytes offset converted from the time by application. This API calls the decoder’s internal seek API to calculate the actual seek offset which frame boundary aligns. This API returns the actual seek offset.</li>
</ul>
<p>The basic sequence to use a decoder with the CCI is shown below:</p>
<div class="image">
<img src="codec_flow.png" alt=""/>
<div class="caption">
cci_decoder_flow</div></div>
    <h2><a class="anchor" id="autotoc_md20"></a>
Adding new decoders to the CCI</h2>
<p>This section explains how to integrate a new decoder in the Common Codec Interface. The CCI assumes the decoder library to be used is in the <code>\middleware\audio_voice\audiocomponents\decoders\*decoder*\libs\</code> folder of the maestro framework. The CCI is just a wrapper around a specific implementation. The decoder is expected to be extended as needed to meet the APIs described above.</p><ul>
<li>Register Decoder Top level APIs in Common Codec Interface<ul>
<li>Place the decoder lib in <code>libs</code> folder.</li>
<li>Add prototypes of the decoder top level APIs in codec_interface.h file (located at <code>maestro\src\cci\inc\</code> folder).</li>
<li>In codec_interface.c file (located at <code>maestro\src\cci\src\</code>), add top level Decoder APIs in decoder function table.</li>
<li>Pseudo code for this is as described below.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> codec_interface_function_table_t g_codec_function_table[STREAM_TYPE_COUNT] = {</div>
<div class="line"><span class="preprocessor">#ifdef VORBIS_CODEC</span></div>
<div class="line">    {</div>
<div class="line">        &amp;VORBISDecoderGetMemorySize,</div>
<div class="line">        &amp;VORBISDecoderInit,</div>
<div class="line">        &amp;VORBISDecoderDecode,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        &amp;VORBISDecoderSeek,</div>
<div class="line">        &amp;VORBISDecoderGetIOFrameSize,</div>
<div class="line">    },</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    {</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li>Enable or Disable Decoder<ul>
<li>Define <code>VORBIS_CODEC</code> macro in audio_cfg.h file.</li>
<li>Comment this macro if you want to disable VORBIS Decoder otherwise keep it defined in order to enable the decoder.</li>
</ul>
</li>
<li>Add Extract Metadata API for the decoder<ul>
<li>Add extract metadata API source file for the decoder at streamer/cci/metadata/src/vorbis folder.</li>
<li>Add this code in extract metadata lib project space.</li>
<li>Build the extract metadata lib and copy that lib to <code>libs</code> folder.</li>
<li>Add the desired stream type into <code>ccidec_extract_meta_data</code> API (in codecextractmetadata.c file) to call VORBIS Decoder extract metadata API.</li>
</ul>
</li>
<li>Add stream type of the new decoder in the stream type enum audio_stream_type_t in codec_interface_public_api.h<ul>
<li>Stream type of the decoder in stream type enum and decoder APIs in decoder function table must be in the same sequence.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md21"></a>
Common encoder interface</h2>
<p>Please see the following section about the <a class="el" href="md_CeiEncoder.html">cei</a>.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Maestro performance</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
Memory information</h2>
<p>The memory usage of the framework components using reference codecs (data obtained from GNU ARM compiler) in bytes is:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">text   </th><th class="markdownTableHeadRight">data   </th><th class="markdownTableHeadRight">bss   </th><th class="markdownTableHeadRight">component    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">48790   </td><td class="markdownTableBodyRight">2752   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">aac decoder    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">4348   </td><td class="markdownTableBodyRight">16400   </td><td class="markdownTableBodyRight">212   </td><td class="markdownTableBodyRight">asrc    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">15512   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">flac decoder    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">76462   </td><td class="markdownTableBodyRight">16   </td><td class="markdownTableBodyRight">5013   </td><td class="markdownTableBodyRight">maestro    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">34211   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">mp3 decoder    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">211974   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">opus    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">65446   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">ssrc    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">5850   </td><td class="markdownTableBodyRight">16   </td><td class="markdownTableBodyRight">12   </td><td class="markdownTableBodyRight">wav decoder   </td></tr>
</table>
<p>Maestro framework uses dynamic allocation of audio buffers. The total amount of memory allocated for the pipeline depends on the following parameters:</p><ul>
<li>Number of elements in the pipeline</li>
<li>Element types</li>
<li>Audio stream properties<ul>
<li>Sampling rate</li>
<li>Bit width</li>
<li>Channel number</li>
<li>Frame size</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md24"></a>
CPU usage</h2>
<p>The performance of the pipeline was measured using the real hardware platform (RT1060).</p><ul>
<li>CPU core clock in MHz: 600.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Pipeline type   </th><th class="markdownTableHeadCenter">Performance MIPS of pipeline (in MHz)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">audio source -&gt; audio sink   </td><td class="markdownTableBodyCenter">~10.26 MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">audio source -&gt; file sink   </td><td class="markdownTableBodyCenter">~9.84 MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">file source (8-channel PCM) -&gt; audio sink   </td><td class="markdownTableBodyCenter">~16.5 MHz   </td></tr>
</table>
<p>For performance details about the supported codecs please see audio-voice-components repository documentation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">&copy; 2020 NXP Semiconductors. All rights reserved.
    </li>
  </ul>
</div>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
      primaryColor: '#f4f4ff',
      secondaryColor: 'rgba(244,244,255,0.9)',
      tertiaryColor: '#F9FAFC',
    },
  });
</script>
</body>
</html>
